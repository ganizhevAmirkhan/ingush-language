<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</title>

<!-- LAME.js –¥–ª—è MP3 –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>

<style>
body {
    font-family: Arial, sans-serif;
    background: var(--bg);
    color: var(--fg);
    padding: 20px;
    margin: 0;
}

:root {
    --bg: #ffffff;
    --fg: #000000;
    --card: #f4f4f4;
}

.dark {
    --bg: #1a1a1a;
    --fg: #e6e6e6;
    --card: #333333;
}

.container {
    max-width: 900px;
    margin: auto;
}

button {
    padding: 8px 14px;
    margin: 5px;
    cursor: pointer;
    border-radius: 6px;
    border: none;
    background: #ddd;
}

button:hover {
    background: #ccc;
}

input, textarea {
    width: 100%;
    padding: 10px;
    margin: 6px 0;
    border-radius: 6px;
    border: 1px solid #aaa;
    font-size: 16px;
}

.item {
    background: var(--card);
    padding: 20px;
    border-radius: 12px;
    margin: 12px 0;
}

.edit-block {
    background: var(--card);
    padding: 20px;
    border-radius: 12px;
    margin-top: 25px;
}

.tts {
    cursor: pointer;
    font-size: 22px;
    margin-left: 5px;
}

#suggestions .sug {
    padding: 6px;
    cursor: pointer;
}

#suggestions .sug:hover {
    background: #ccc;
}

.highlight {
    background: yellow;
}
</style>
</head>

<body>
<div class="container">

<h1>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</h1>

<!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
<button onclick="login()">–í–æ–π—Ç–∏</button>
<button onclick="logout()">–í—ã–π—Ç–∏</button>
<span id="authStatus"></span>

<br><br>

<button onclick="setMode('auto')">–ê–≤—Ç–æ</button>
<button onclick="setMode('ru2ing')">Ru ‚Üí Ing</button>
<button onclick="setMode('ing2ru')">Ing ‚Üí Ru</button>
<button onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>

<br><br>

<input id="query" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ..." oninput="autocomplete()" />
<div id="suggestions"></div>
<button onclick="search()">–ü–æ–∏—Å–∫</button>

<div id="result"></div>

<!-- –†–µ–¥–∞–∫—Ç–æ—Ä -->
<div id="editor" class="edit-block" style="display:none;">
<h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞</h3>

–†—É—Å—Å–∫–æ–µ —Å–ª–æ–≤–æ:
<input id="edit_russian">

–ò–Ω–≥—É—à—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):
<input id="edit_ingush">

–ß–∞—Å—Ç—å —Ä–µ—á–∏:
<input id="edit_pos">

–¢–æ–ª–∫–æ–≤–∞–Ω–∏–µ:
<textarea id="edit_definition"></textarea>

<button onclick="saveEdit()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
<button onclick="closeEditor()">–ó–∞–∫—Ä—ã—Ç—å</button>
<button onclick="downloadUpdated()">‚¨á –°–∫–∞—á–∞—Ç—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</button>
</div>

<!-- –ê—É–¥–∏–æ –ø–∞–Ω–µ–ª—å -->
<div id="audioAdmin" class="edit-block" style="display:none;">
<h3>üé§ –ó–∞–ø–∏—Å—å –∞—É–¥–∏–æ</h3>

–ò–Ω–≥—É—à—Å–∫–æ–µ —Å–ª–æ–≤–æ:
<input id="rec_word" placeholder="iyrcha" />

<button onclick="startRecording()">‚ñ∂ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
<button onclick="stopRecording()">‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

<p id="rec_status"></p>
<a id="download_rec" style="display:none;" download>‚¨á –°–∫–∞—á–∞—Ç—å MP3</a>

<hr>

<h3>‚¨Ü –ó–∞–≥—Ä—É–∑–∫–∞ MP3 –≤ GitHub</h3>
GitHub Token:
<input id="gh_token" placeholder="ghp_xxx..." oninput="saveToken()" />
<button onclick="uploadLastMP3()">–ó–∞–≥—Ä—É–∑–∏—Ç—å MP3</button>
</div>

</div> <!-- /container -->

<script>
const PASSWORD = "ingush-secret";
let MODE = "auto";
let DICT = {};
let currentKey = null;

let mediaRecorder = null;
let chunks = [];
let lastMP3Blob = null;

/* ============================  –¢–ï–ú–ê  ============================ */
function toggleTheme(){
    document.body.classList.toggle("dark");
}

/* ======================  –ê–í–¢–û–†–ò–ó–ê–¶–ò–Ø  =========================== */
function updateAuth(){
    authStatus.textContent = localStorage.getItem("authorized")
        ? "‚úî –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
        : "‚úñ –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω";
}
updateAuth();

function login(){
    const p = prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:");
    if(p === PASSWORD){
        localStorage.setItem("authorized", "true");
        updateAuth();
    } else alert("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å");
}

function logout(){
    localStorage.removeItem("authorized");
    updateAuth();
}

/* ======================  –ó–ê–ì–†–£–ó–ö–ê –°–õ–û–í–ê–†–Ø  ====================== */
async function loadDict(){
    const r = await fetch("merged_dictionary_rebuilt.json");
    DICT = await r.json();

    const edits = localStorage.getItem("dict_edits");
    if(edits) Object.assign(DICT, JSON.parse(edits));
}
loadDict();


/* ======================  –ü–û–ò–°–ö + AUTOCOMPLETE ================== */
function setMode(m){ MODE = m; }

function autocomplete(){
    const q = query.value.toLowerCase().trim();
    if(!q){
        suggestions.innerHTML = "";
        return;
    }

    const list = Object.keys(DICT)
        .filter(k => k.toLowerCase().startsWith(q))
        .slice(0, 10);

    suggestions.innerHTML = list.map(k =>
        `<div class="sug" onclick="useSuggestion('${k}')">${k}</div>`
    ).join("");
}

function useSuggestion(w){
    query.value = w;
    suggestions.innerHTML = "";
    search();
}

function search(){
    const q = query.value.toLowerCase().trim();
    let keys = [];

    if(MODE === "ru2ing"){
        keys = Object.keys(DICT).filter(k => k.toLowerCase().includes(q));
    }
    else if(MODE === "ing2ru"){
        keys = Object.keys(DICT).filter(k =>
            DICT[k].ingush.some(t => t.toLowerCase().includes(q))
        );
    }
    else {
        keys = Object.keys(DICT).filter(k =>
            k.toLowerCase().includes(q) ||
            DICT[k].ingush.some(t => t.toLowerCase().includes(q))
        );
    }

    renderResult(keys);
}

function renderResult(keys){
    result.innerHTML = keys.map(k=>{
        const e = DICT[k];
        const ing = e.ingush.join(", ");
        const firstIng = e.ingush[0] || "";

        return `
        <div class="item">
            <b>${k}</b><br>

            <span>${ing}</span>
            <span class="tts" onclick="playIng('${firstIng}')">üéß</span>
            <span class="tts" onclick="prepareRecord('${firstIng}')">üé§</span>

            <br><br>
            <small>${e.definition || ""}</small><br><br>

            ${localStorage.getItem("authorized")
                ? `<button onclick="openEditor('${k}')">‚úè –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>`
                : ""}
        </div>`;
    }).join("");
}


/* ======================  –¢–†–ê–ù–°–õ–ò–¢ ============================= */

function translitIngush(text) {
    const map = {
        "–∞":"a","–±":"b","–≤":"v","–≥":"g","–≥”Ä":"gh","–¥":"d","–µ":"e","—ë":"yo","–∂":"zh","–∑":"z",
        "–∏":"i","–π":"y","–∫":"k","–∫”Ä":"kh","–ª":"l","–º":"m","–Ω":"n","–æ":"o","–ø":"p","—Ä":"r",
        "—Å":"s","—Ç":"t","—É":"u","—Ñ":"f","—Ö":"h","—Ö”Ä":"hh","—Ü":"ts","—Ü”Ä":"ts'","—á":"ch",
        "—á”Ä":"ch'","—à":"sh","—â":"sch","—ã":"y","—ç":"e","—é":"yu","—è":"ya","”Ä":"i",
        "—å":"","—ä":"",
        " ":"_","‚Äô":"", " º":"", "'":""
    };

    let out = text.toLowerCase();
    for (let key in map){
        out = out.replaceAll(key, map[key]);
    }

    return out.replace(/[^a-z0-9_]/g, "");
}


/* ======================  –ü–†–û–í–ï–†–ö–ê –ù–ê–õ–ò–ß–ò–Ø MP3 ====================== */

async function audioExists(word){
    const fname = translitIngush(word) + ".mp3";
    const url = `https://api.github.com/repos/ganizhevamirkhan/ingush-language/contents/audio/${fname}`;

    const r = await fetch(url, { method: "GET" });

    return r.status === 200;
}


/* ======================  –í–û–°–ü–†–û–ò–ó–í–ï–î–ï–ù–ò–ï MP3 ====================== */

async function playIng(word){
    const fname = translitIngush(word) + ".mp3";
    const localUrl = "audio/" + fname;

    if(await audioExists(word)){
        new Audio(localUrl).play();
        return;
    }

    const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q=${encodeURIComponent(word)}&tl=ru`;
    new Audio(url).play();
}


/* ======================  –ü–û–î–ì–û–¢–û–í–ö–ê –ö –ó–ê–ü–ò–°–ò ====================== */

function prepareRecord(ingushWord){
    if(!localStorage.getItem("authorized")){
        alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞! –í–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.");
        return;
    }

    audioAdmin.style.display = "block";
    rec_word.value = ingushWord;
    rec_status.innerText = "–ì–æ—Ç–æ–≤ –∫ –∑–∞–ø–∏—Å–∏: " + ingushWord;
}


/* ========================  –ó–ê–ü–ò–°–¨ –ê–£–î–ò–û ========================= */

async function startRecording(){
    chunks = [];
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    mediaRecorder = new MediaRecorder(stream);

    mediaRecorder.ondataavailable = e => chunks.push(e.data);

    mediaRecorder.start();
    rec_status.innerText = "üéô –ó–∞–ø–∏—Å—å...";
}

async function stopRecording(){
    mediaRecorder.stop();
    rec_status.innerText = "‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞...";

    mediaRecorder.onstop = async () => {
        const wavBlob = new Blob(chunks, {type: "audio/wav"});
        const trimmed = await trimSilence(wavBlob);
        lastMP3Blob = await wavToMp3(trimmed);

        const word = rec_word.value.trim();
        const fname = translitIngush(word) + ".mp3";

        download_rec.href = URL.createObjectURL(lastMP3Blob);
        download_rec.download = fname;
        download_rec.style.display = "inline-block";

        rec_status.innerText = "‚úî –ì–æ—Ç–æ–≤–æ: " + fname;
    };
}


/* ========================  –û–ë–†–ï–ó–ö–ê –¢–ò–®–ò–ù–´ ========================= */

async function trimSilence(blob, threshold = 0.02){
    const ctx = new AudioContext();
    const buf = await blob.arrayBuffer();
    const audio = await ctx.decodeAudioData(buf);
    const data = audio.getChannelData(0);

    let start = 0;
    let end = data.length - 1;

    while(Math.abs(data[start]) < threshold && start < end) start++;
    while(Math.abs(data[end]) < threshold && end > start) end--;

    const trimmedArray = data.slice(start, end);
    const newBuf = ctx.createBuffer(1, trimmedArray.length, audio.sampleRate);
    newBuf.copyToChannel(trimmedArray, 0);

    return encodeWav(newBuf);
}


/* ========================  –ö–û–î–ò–†–û–í–ê–ù–ò–ï WAV ========================= */

function encodeWav(buffer){
    const numSamples = buffer.length;
    const sampleRate = buffer.sampleRate;
    const bytesPerSample = 2;

    const blockAlign = bytesPerSample * 1;

    const buf = new ArrayBuffer(44 + numSamples * bytesPerSample);
    const view = new DataView(buf);

    function writeString(off, str){
        for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i));
    }

    writeString(0, "RIFF");
    view.setUint32(4, 36 + numSamples * bytesPerSample, true);
    writeString(8, "WAVEfmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * bytesPerSample, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);

    writeString(36, "data");
    view.setUint32(40, numSamples * bytesPerSample, true);

    let offset = 44;
    const channel = buffer.getChannelData(0);

    for(let i=0;i<channel.length;i++){
        let s = Math.max(-1, Math.min(1, channel[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
    }

    return new Blob([buf], {type: "audio/wav"});
}


/* ========================  WAV ‚Üí MP3 (128 kbps) ========================= */

async function wavToMp3(blob){
    const buffer = await blob.arrayBuffer();
    const wav = lamejs.WavHeader.readHeader(new DataView(buffer));
    const samples = new Int16Array(buffer, wav.dataOffset, wav.dataLen / 2);

    const mp3enc = new lamejs.Mp3Encoder(1, wav.sampleRate, 128); 
    const mp3Data = [];

    let remaining = samples.length;
    let position = 0;

    while(remaining > 0){
        const chunkSize = 1152;
        const left = samples.subarray(position, position + chunkSize);
        const mp3buf = mp3enc.encodeBuffer(left);

        if(mp3buf.length > 0) mp3Data.push(mp3buf);

        position += chunkSize;
        remaining -= chunkSize;
    }

    const end = mp3enc.flush();
    if(end.length > 0) mp3Data.push(end);

    return new Blob(mp3Data, {type: "audio/mp3"});
}


/* ========================  –ó–ê–ì–†–£–ó–ö–ê MP3 –í GITHUB ========================= */

function saveToken(){
    localStorage.setItem("gh_token", gh_token.value.trim());
}

async function uploadLastMP3(){
    if(!lastMP3Blob){
        alert("–ù–µ—Ç MP3 ‚Äî —Å–Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—à–∏—Ç–µ —Å–ª–æ–≤–æ.");
        return;
    }

    const token = localStorage.getItem("gh_token");
    if(!token){
        alert("–í–≤–µ–¥–∏—Ç–µ GitHub Token!");
        return;
    }

    const word = rec_word.value.trim();
    const fname = translitIngush(word) + ".mp3";
    const repo = "ganizhevamirkhan/ingush-language";
    const path = "audio/" + fname;

    const buf = await lastMP3Blob.arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));

    const url = `https://api.github.com/repos/${repo}/contents/${path}`;

    const body = {
        message: "–î–æ–±–∞–≤–ª–µ–Ω MP3: " + fname,
        content: b64
    };

    const r = await fetch(url, {
        method: "PUT",
        headers: {
            "Authorization": "token " + token,
            "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
    });

    if(r.status === 201 || r.status === 200){
        alert("‚úî MP3 –∑–∞–≥—Ä—É–∂—ë–Ω –≤ GitHub!");
    } else {
        alert("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: " + r.status);
    }
}


/* ========================= –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï –°–õ–û–í ========================= */

function openEditor(key){
    if(!localStorage.getItem("authorized")){
        alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!");
        return;
    }

    currentKey = key;
    const e = DICT[key];

    edit_russian.value = e.russian;
    edit_ingush.value = e.ingush.join(", ");
    edit_pos.value = e.pos || "";
    edit_definition.value = e.definition || "";

    editor.style.display = "block";
}

function closeEditor(){
    editor.style.display = "none";
}

function saveEdit(){
    if(!currentKey) return;

    const rus = edit_russian.value.trim();
    const ing = edit_ingush.value.split(",").map(s => s.trim());

    DICT[rus] = {
        russian: rus,
        ingush: ing,
        pos: edit_pos.value.trim(),
        definition: edit_definition.value.trim(),
        source: "edited"
    };

    localStorage.setItem("dict_edits", JSON.stringify(DICT));

    alert("‚úî –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã");
    editor.style.display = "none";

    search();
}


/* =============== –°–ö–ê–ß–ê–¢–¨ –û–ë–ù–û–í–õ–Å–ù–ù–´–ô –°–õ–û–í–ê–†–¨ ================= */

function downloadUpdated(){
    const blob = new Blob([JSON.stringify(DICT, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "dictionary_updated.json";
    a.click();
}

</script>

</body>
</html>
