<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</title>

<!-- FFmpeg for WAV ‚Üí MP3 -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.2/dist/ffmpeg.min.js"></script>

<style>
body {
    font-family: Arial, sans-serif;
    background: var(--bg);
    color: var(--fg);
    margin: 0; padding: 20px;
}
:root {
    --bg: #ffffff;
    --fg: #000000;
    --card: #f0f0f0;
}
.dark {
    --bg: #1b1b1b;
    --fg: #f0f0f0;
    --card: #333;
}

.container { max-width: 900px; margin: auto; }

input, textarea {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin: 5px 0;
}
button {
    padding: 10px 15px;
    margin: 4px;
    cursor: pointer;
}
.item {
    padding: 15px;
    margin-top: 10px;
    background: var(--card);
    border-radius: 8px;
}
.tts-btn { cursor: pointer; margin-left: 8px; font-size: 20px; }

.edit-block {
    margin-top: 20px;
    padding: 15px;
    background: var(--card);
    border-radius: 8px;
}

#suggestions { background: var(--card); border-radius: 5px; }
.sug-item { padding: 6px; cursor: pointer; }
.sug-item:hover { background: #ddd; }

.highlight { background: yellow; }
</style>
</head>

<body>
<div class="container">

<h1>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</h1>

<button onclick="login()">–í–æ–π—Ç–∏</button>
<button onclick="logout()">–í—ã–π—Ç–∏</button>
<span id="authStatus"></span>

<div>
    <button onclick="setMode('auto')">–ê–≤—Ç–æ</button>
    <button onclick="setMode('ru2ing')">Ru ‚Üí Ing</button>
    <button onclick="setMode('ing2ru')">Ing ‚Üí Ru</button>
    <button onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>
    <button onclick="openAudioAdmin()">üéß –ê—É–¥–∏–æ</button>
</div>

<input id="query" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ..." oninput="autocomplete()">
<div id="suggestions"></div>
<button onclick="search()">–ü–æ–∏—Å–∫</button>

<div id="result"></div>

<!-- ======================= EDITOR ======================= -->
<div id="editor" class="edit-block" style="display:none;">
    <h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞</h3>

    –†—É—Å—Å–∫–æ–µ —Å–ª–æ–≤–æ:
    <input id="edit_russian">

    –ü–µ—Ä–µ–≤–æ–¥—ã (–∏–Ω–≥—É—à—Å–∫–∏–µ):
    <input id="edit_ingush">

    –ß–∞—Å—Ç—å —Ä–µ—á–∏:
    <input id="edit_pos">

    –¢–æ–ª–∫–æ–≤–∞–Ω–∏–µ:
    <textarea id="edit_definition"></textarea>

    <button onclick="saveEdit()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    <button onclick="closeEditor()">–ó–∞–∫—Ä—ã—Ç—å</button>
    <hr>
    <button onclick="downloadUpdated()">‚¨á –°–∫–∞—á–∞—Ç—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</button>
</div>

<!-- ======================= AUDIO PANEL ======================= -->
<div id="audioAdmin" class="edit-block" style="display:none;">
    <h3>üé§ –ó–∞–ø–∏—Å—å –∞—É–¥–∏–æ</h3>

    –ò–Ω–≥—É—à—Å–∫–æ–µ —Å–ª–æ–≤–æ:
    <input id="rec_word" placeholder="iyrcha">

    <button onclick="startRecording()">‚ñ∂ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
    <button onclick="stopRecording()">‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

    <p id="rec_status"></p>
    <a id="download_rec" style="display:none;" download>‚¨á –°–∫–∞—á–∞—Ç—å MP3</a>

    <hr>
    <h3>‚¨Ü –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ MP3 –≤ GitHub</h3>

    GitHub Token:
    <input id="gh_token" placeholder="ghp_xxx..." oninput="saveToken()">

    <button onclick="uploadLastMP3()">‚¨Ü –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤ GitHub</button>
</div>

</div>

<script>
/* ======================== AUTH ======================== */
const PASSWORD = "ingush-secret";

function updateStatus() {
    authStatus.innerText =
        localStorage.getItem("authorized") ? "‚úî –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" : "‚úñ –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω";
}
updateStatus();

function login() {
    const pass = prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:");
    if (pass === PASSWORD) {
        localStorage.setItem("authorized", "true");
    } else alert("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å");
    updateStatus();
}
function logout() {
    localStorage.removeItem("authorized");
    updateStatus();
}

/* ======================== THEME ======================== */
function toggleTheme() { document.body.classList.toggle("dark"); }

/* ======================== DICTIONARY ======================== */
let MODE = "auto";
let DICT = {};
let currentEditKey = null;

async function loadDict() {
    const r = await fetch("merged_dictionary_rebuilt.json");
    DICT = await r.json();

    const edits = localStorage.getItem("dict_edits");
    if (edits) Object.assign(DICT, JSON.parse(edits));
}
loadDict();

function setMode(m) { MODE = m; }

function autocomplete() {
    const q = query.value.trim().toLowerCase();
    if (!q) return suggestions.innerHTML = "";

    const list = Object.keys(DICT)
        .filter(k => k.toLowerCase().startsWith(q))
        .slice(0, 10);

    suggestions.innerHTML = list
        .map(k => `<div class='sug-item' onclick="useSuggestion('${k}')">${k}</div>`)
        .join("");
}
function useSuggestion(w) {
    query.value = w;
    suggestions.innerHTML = "";
    search();
}

function search() {
    const q = query.value.trim().toLowerCase();
    if (!q) return;

    const results = Object.keys(DICT).filter(k => {
        const e = DICT[k];
        if (MODE === "ru2ing") return k.toLowerCase().startsWith(q);
        if (MODE === "ing2ru") return e.ingush.some(t => t.startsWith(q));
        return k.toLowerCase().startsWith(q) ||
               e.ingush.some(t => t.startsWith(q));
    });
    renderResults(results, q);
}

function renderResults(keys, q) {
    result.innerHTML = keys.map(k => {
        const e = DICT[k];

        return `
            <div class="item">
                <b>${k}</b>
                <span class="tts-btn" onclick="speakRu('${k}')">üó£</span><br>
                ${e.ingush.join(", ")}
                <span class="tts-btn" onclick="playProtected('${e.ingush[0]}')">üéß</span><br>
                <small>${e.definition || "‚Äî"}</small><br><br>
                ${localStorage.getItem("authorized")
                    ? `<button onclick="openEditor('${k}')">‚úè –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>`
                    : ""}
            </div>
        `;
    }).join("");
}

/* ======================== TTS RU ======================== */
function speakRu(t) {
    const u = new SpeechSynthesisUtterance(t);
    u.lang = "ru-RU";
    speechSynthesis.speak(u);
}

/* ======================== AUDIO NORMALIZATION ======================== */
function latinize(s) {
    const map = {
        "–∞":"a","–±":"b","–≤":"v","–≥":"g","–¥":"d","–µ":"e","—ë":"yo","–∂":"zh","–∑":"z",
        "–∏":"i","–π":"y","–∫":"k","–ª":"l","–º":"m","–Ω":"n","–æ":"o","–ø":"p","—Ä":"r",
        "—Å":"s","—Ç":"t","—É":"u","—Ñ":"f","—Ö":"kh","—Ü":"ts","—á":"ch","—à":"sh","—â":"shh",
        "—ã":"y","—ç":"e","—é":"yu","—è":"ya",
        "”Ä":"i","”è":"i"
    };
    return s.toLowerCase().split("").map(c => map[c] || c).join("");
}
function normalizeAudioName(word) {
    return latinize(word).replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}

/* ======================== PLAY with FALLBACK ======================== */
async function playProtected(word) {
    if (!localStorage.getItem("authorized"))
        return alert("–ù—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");

    const file = normalizeAudioName(word) + ".mp3";
    const url = "audio/" + file;

    const check = await fetch(url, { method: "HEAD" });
    if (check.ok) {
        new Audio(url).play();
    } else {
        const tts = "https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q="
            + encodeURIComponent(word) + "&tl=ru";
        new Audio(tts).play();
    }
}

/* ======================== EDITOR ======================== */
function openEditor(k) {
    const e = DICT[k];
    currentEditKey = k;
    edit_russian.value = k;
    edit_ingush.value = e.ingush.join(", ");
    edit_pos.value = e.pos || "";
    edit_definition.value = e.definition || "";
    editor.style.display = "block";
}
function closeEditor(){ editor.style.display = "none"; }

function saveEdit() {
    const rus = edit_russian.value.trim();
    const ing = edit_ingush.value.split(",").map(s => s.trim());

    DICT[rus] = {
        russian: rus,
        ingush: ing,
        pos: edit_pos.value.trim(),
        definition: edit_definition.value.trim(),
        source: "edited"
    };
    localStorage.setItem("dict_edits", JSON.stringify(DICT));
    alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!");
}

function downloadUpdated() {
    const blob = new Blob([JSON.stringify(DICT,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "updated_dictionary.json";
    a.click();
}

/* ======================== AUDIO PANEL ======================== */

function openAudioAdmin() {
    if (!localStorage.getItem("authorized"))
        return alert("–ù—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
    audioAdmin.style.display = "block";
}

/* -------- RECORD + TRIM + MP3 -------- */

const { createFFmpeg, fetchFile } = FFmpeg;
const ffmpeg = createFFmpeg({ log:false });

let mediaRecorder;
let chunks = [];
let lastMP3 = null;

async function startRecording() {
    if (!localStorage.getItem("authorized"))
        return alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞");

    chunks = [];
    rec_status.innerText = "üéô –ó–∞–ø–∏—Å—å‚Ä¶";

    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.start();
}

async function stopRecording() {
    if (!mediaRecorder) return;

    rec_status.innerText = "‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞‚Ä¶";
    mediaRecorder.stop();

    mediaRecorder.onstop = async () => {
        const wav = new Blob(chunks, { type:"audio/wav" });
        const trimmed = await trimSilence(wav);
        lastMP3 = await wavToMp3(trimmed);

        const name = normalizeAudioName(rec_word.value.trim()) + ".mp3";
        download_rec.href = URL.createObjectURL(lastMP3);
        download_rec.download = name;
        download_rec.style.display = "inline-block";

        rec_status.innerHTML = `‚úî –ì–æ—Ç–æ–≤–æ! –§–∞–π–ª: <b>${name}</b>`;
    };
}

async function wavToMp3(blob) {
    if (!ffmpeg.isLoaded()) await ffmpeg.load();
    ffmpeg.FS("writeFile","in.wav", await fetchFile(blob));
    await ffmpeg.run("-i","in.wav","-codec:a","libmp3lame","out.mp3");
    const data = ffmpeg.FS("readFile","out.mp3");
    return new Blob([data.buffer], {type:"audio/mp3"});
}

/* -------- SILENCE TRIM -------- */

async function trimSilence(blob, threshold=0.02) {
    const ctx = new AudioContext();
    const ab = await blob.arrayBuffer();
    const audio = await ctx.decodeAudioData(ab);
    const samples = audio.getChannelData(0);

    let start=0, end=samples.length-1;
    while (Math.abs(samples[start])<threshold && start<end) start++;
    while (Math.abs(samples[end])<threshold && end>start) end--;

    const trimmed = samples.slice(start,end);
    const newBuf = ctx.createBuffer(1, trimmed.length, audio.sampleRate);
    newBuf.copyToChannel(trimmed, 0);

    return bufferToWav(newBuf);
}

async function bufferToWav(buffer) {
    const length = buffer.length*2 + 44;
    const array = new ArrayBuffer(length);
    const view = new DataView(array);

    writeHeader(view, buffer.sampleRate, buffer.length);

    let offset = 44;
    const samples = buffer.getChannelData(0);

    for (let i=0;i<samples.length;i++,offset+=2) {
        const s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }

    return new Blob([array], {type:"audio/wav"});
}

function writeHeader(view, rate, length) {
    function w(o,s){for(let i=0;i<s.length;i++)view.setUint8(o+i,s.charCodeAt(i));}

    w(0,"RIFF");
    view.setUint32(4, 36 + length*2, true);
    w(8,"WAVEfmt ");
    view.setUint32(16,16,true);
    view.setUint16(20,1,true);
    view.setUint16(22,1,true);
    view.setUint32(24,rate,true);
    view.setUint32(28,rate*2,true);
    view.setUint16(32,2,true);
    view.setUint16(34,16,true);
    w(36,"data");
    view.setUint32(40,length*2,true);
}

/* -------- GitHub Upload -------- */

function saveToken() {
    localStorage.setItem("gh_token", gh_token.value.trim());
}

async function uploadLastMP3() {
    if (!lastMP3) return alert("–°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—à–∏—Ç–µ MP3!");

    const token = localStorage.getItem("gh_token");
    if (!token) return alert("–í–≤–µ–¥–∏—Ç–µ GitHub —Ç–æ–∫–µ–Ω!");

    const repo = "ganizhevamirkhan/ingush-language";
    const fileName = normalizeAudioName(rec_word.value.trim()) + ".mp3";

    const buf = await lastMP3.arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));

    await fetch(`https://api.github.com/repos/${repo}/contents/audio/${fileName}`,{
        method:"PUT",
        headers:{ "Authorization":"token "+token },
        body: JSON.stringify({
            message:"–î–æ–±–∞–≤–ª–µ–Ω MP3: "+fileName,
            content:b64
        })
    });

    alert("‚úî –ó–∞–≥—Ä—É–∂–µ–Ω–æ –≤ GitHub!");
}

</script>
</body>
</html>
