<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</title>

<!-- FFmpeg ‚Äî —Ä–∞–±–æ—á–∞—è –≤–µ—Ä—Å–∏—è -->
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.2/dist/ffmpeg.min.js"></script>

<style>
body { font-family: Arial, sans-serif; background: var(--bg); color:var(--fg); padding:20px; margin:0; }
:root { --bg:#fff; --fg:#000; --card:#efefef; }
.dark { --bg:#1c1c1c; --fg:#eee; --card:#333; }

.container { max-width:900px; margin:auto; }

button { padding:8px 14px; margin:4px; cursor:pointer; }
input, textarea { width:100%; padding:10px; margin:6px 0; font-size:16px; }

.item, .edit-block {
    background:var(--card); padding:15px; border-radius:8px; margin:15px 0;
}

.tts { cursor:pointer; font-size:20px; margin-left:5px; }

#suggestions .sug { padding:5px; cursor:pointer; }
#suggestions .sug:hover { background:#ccc; }

.highlight { background:yellow; }
</style>
</head>

<body>
<div class="container">

<h1>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</h1>

<button onclick="login()">–í–æ–π—Ç–∏</button>
<button onclick="logout()">–í—ã–π—Ç–∏</button>
<span id="authStatus"></span>

<br><br>

<button onclick="setMode('auto')">–ê–≤—Ç–æ</button>
<button onclick="setMode('ru2ing')">Ru ‚Üí Ing</button>
<button onclick="setMode('ing2ru')">Ing ‚Üí Ru</button>
<button onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>
<button onclick="openAudioAdmin()">–ê—É–¥–∏–æ</button>

<br><br>

<input id="query" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ..." oninput="autocomplete()">
<div id="suggestions"></div>
<button onclick="search()">–ü–æ–∏—Å–∫</button>

<div id="result"></div>

<!-- –†–µ–¥–∞–∫—Ç–æ—Ä —Å–ª–æ–≤ -->
<div id="editor" class="edit-block" style="display:none;">
<h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏</h3>

–†—É—Å—Å–∫–æ–µ —Å–ª–æ–≤–æ:  
<input id="edit_russian">

–ò–Ω–≥—É—à—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):  
<input id="edit_ingush">

–ß–∞—Å—Ç—å —Ä–µ—á–∏:  
<input id="edit_pos">

–¢–æ–ª–∫–æ–≤–∞–Ω–∏–µ:  
<textarea id="edit_definition"></textarea>

<button onclick="saveEdit()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
<button onclick="closeEditor()">–ó–∞–∫—Ä—ã—Ç—å</button>

<br><br>

<button onclick="downloadUpdated()">‚¨á –°–∫–∞—á–∞—Ç—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</button>
</div>

<!-- –ê—É–¥–∏–æ –º–æ–¥—É–ª—å -->
<div id="audioAdmin" class="edit-block" style="display:none;">
<h3>üé§ –ó–∞–ø–∏—Å—å –∞—É–¥–∏–æ</h3>

–ò–Ω–≥—É—à—Å–∫–æ–µ —Å–ª–æ–≤–æ:  
<input id="rec_word" placeholder="iyrcha">

<button onclick="startRecording()">‚ñ∂ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
<button onclick="stopRecording()">‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

<p id="rec_status"></p>
<a id="download_rec" style="display:none;" download>‚¨á –°–∫–∞—á–∞—Ç—å MP3</a>

<hr>

<h3>–ó–∞–≥—Ä—É–∑–∫–∞ MP3 –≤ GitHub</h3>

GitHub Token:  
<input id="gh_token" placeholder="ghp_xxx..." oninput="saveToken()">

<button onclick="uploadLastMP3()">‚¨Ü –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤ GitHub</button>
</div>

</div>

<script>
/* ======================= –ê–í–¢–û–†–ò–ó–ê–¶–ò–Ø ======================= */
const PASSWORD = "ingush-secret";

function updateStatus(){
    authStatus.textContent =
        localStorage.getItem("authorized") ? "‚úî –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" : "‚úñ –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω";
}
updateStatus();

function login(){
    const p = prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:");
    if(p === PASSWORD){
        localStorage.setItem("authorized","true");
    } else alert("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å");
    updateStatus();
}
function logout(){
    localStorage.removeItem("authorized");
    updateStatus();
}

/* ======================= –¢–ï–ú–ê ======================= */
function toggleTheme(){
    document.body.classList.toggle("dark");
}

/* ======================= –°–õ–û–í–ê–†–¨ ======================= */
let MODE = "auto";
let DICT = {};
let currentEditKey = null;

async function loadDict(){
    const r = await fetch("merged_dictionary_rebuilt.json");
    DICT = await r.json();

    const edits = localStorage.getItem("dict_edits");
    if(edits) Object.assign(DICT, JSON.parse(edits));
}
loadDict();

function setMode(m){ MODE = m; }

/* ======================= –ü–û–ò–°–ö ======================= */
function autocomplete(){
    const q = query.value.toLowerCase().trim();
    if(!q){ suggestions.innerHTML=""; return; }

    const list = Object.keys(DICT)
        .filter(k => k.toLowerCase().startsWith(q))
        .slice(0,10);

    suggestions.innerHTML = list
        .map(k => `<div class='sug' onclick="useSuggestion('${k}')">${k}</div>`)
        .join("");
}

function useSuggestion(w){
    query.value = w;
    suggestions.innerHTML = "";
    search();
}

function search(){
    const q = query.value.toLowerCase().trim();
    if(!q) return;

    const keys = Object.keys(DICT).filter(k=>{
        const e = DICT[k];
        if(MODE==="ru2ing") return k.toLowerCase().startsWith(q);
        if(MODE==="ing2ru") return e.ingush.some(t => t.toLowerCase().startsWith(q));
        return k.toLowerCase().startsWith(q) ||
               e.ingush.some(t => t.toLowerCase().startsWith(q));
    });

    renderResults(keys);
}

function renderResults(keys){
    result.innerHTML = keys.map(k=>{
        const e = DICT[k];
        const i = e.ingush.join(", ");

        return `
        <div class="item">
            <b>${k}</b>
            <span class="tts" onclick="speakRu('${k}')">üó£</span><br>

            ${i}
            <span class="tts" onclick="playAudio('${e.ingush[0]}')">üéß</span><br>

            <small>${e.definition || "‚Äî –Ω–µ—Ç —Ç–æ–ª–∫–æ–≤–∞–Ω–∏—è ‚Äî"}</small><br><br>

            ${localStorage.getItem("authorized")
                ? `<button onclick="openEditor('${k}')">‚úè –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>`
                : ""}
        </div>`;
    }).join("");
}

/* ======================= –û–ó–í–£–ß–ö–ê RU ======================= */
function speakRu(text){
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "ru-RU";
    speechSynthesis.speak(u);
}

/* ======================= –ü–†–û–ò–ì–†–´–í–ê–ù–ò–ï –ê–£–î–ò–û ======================= */
function latinize(s){
    const map = {"–∞":"a","–±":"b","–≤":"v","–≥":"g","–¥":"d","–µ":"e","—ë":"yo","–∂":"zh","–∑":"z",
        "–∏":"i","–π":"y","–∫":"k","–ª":"l","–º":"m","–Ω":"n","–æ":"o","–ø":"p","—Ä":"r","—Å":"s",
        "—Ç":"t","—É":"u","—Ñ":"f","—Ö":"kh","—Ü":"ts","—á":"ch","—à":"sh","—â":"shh","—ã":"y",
        "—ç":"e","—é":"yu","—è":"ya","”Ä":"i","”è":"i"};
    return s.toLowerCase().split("").map(c=>map[c]||c).join("");
}

function normalizeAudioName(w){
    return latinize(w).replace(/[^a-z0-9]+/g,"_");
}

async function playAudio(word){
    if(!localStorage.getItem("authorized"))
        return alert("–ù—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!");

    const file = normalizeAudioName(word)+".mp3";
    const url  = "audio/"+file;

    const head = await fetch(url,{method:"HEAD"});

    if(head.ok){
        new Audio(url).play();
    } else {
        new Audio(
            "https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q="
            + encodeURIComponent(word) + "&tl=ru"
        ).play();
    }
}

/* ======================= –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï ======================= */
function openEditor(k){
    currentEditKey = k;
    const e = DICT[k];

    edit_russian.value = k;
    edit_ingush.value = e.ingush.join(", ");
    edit_pos.value = e.pos || "";
    edit_definition.value = e.definition || "";

    editor.style.display = "block";
}

function closeEditor(){ editor.style.display = "none"; }

function saveEdit(){
    const rus = edit_russian.value.trim();
    const ing = edit_ingush.value.split(",").map(s=>s.trim());

    DICT[rus] = {
        russian: rus,
        ingush: ing,
        pos: edit_pos.value.trim(),
        definition: edit_definition.value.trim(),
        source: "edited"
    };

    localStorage.setItem("dict_edits", JSON.stringify(DICT));
    alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!");
}

function downloadUpdated(){
    const blob = new Blob([JSON.stringify(DICT,null,2)],{type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "dictionary_updated.json";
    a.click();
}

/* ======================= –ê–£–î–ò–û –ó–ê–ü–ò–°–¨ ======================= */
let mediaRecorder=null, chunks=[], lastMP3Blob=null;

function openAudioAdmin(){
    if(!localStorage.getItem("authorized")) return alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞");
    audioAdmin.style.display="block";
}

async function startRecording(){
    chunks=[];
    rec_status.innerText="üéô –ó–∞–ø–∏—Å—å...";

    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable=e=>chunks.push(e.data);
    mediaRecorder.start();
}

async function stopRecording(){
    if(!mediaRecorder) return;

    rec_status.innerText="‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞...";
    mediaRecorder.stop();

    mediaRecorder.onstop = async ()=>{
        const wavBlob = new Blob(chunks,{type:"audio/wav"});
        const trimmed = await trimSilence(wavBlob);
        lastMP3Blob = await wavToMp3(trimmed);

        const name = normalizeAudioName(rec_word.value)+".mp3";
        download_rec.href = URL.createObjectURL(lastMP3Blob);
        download_rec.download = name;
        download_rec.style.display="inline-block";

        rec_status.innerText="‚úî –ì–æ—Ç–æ–≤–æ: "+name;
    };
}

/* WAV ‚Üí MP3 */
async function wavToMp3(blob){
    if(!ffmpeg.isLoaded()) await ffmpeg.load();
    ffmpeg.FS("writeFile","in.wav", await FFmpeg.fetchFile(blob));
    await ffmpeg.run("-i","in.wav","-codec:a","libmp3lame","out.mp3");
    const data = ffmpeg.FS("readFile","out.mp3");
    return new Blob([data.buffer],{type:"audio/mp3"});
}

/* === –û–±—Ä–µ–∑–∞–Ω–∏–µ —Ç–∏—à–∏–Ω—ã === */
async function trimSilence(blob, th=0.02){
    const ctx=new AudioContext();
    const buf=await blob.arrayBuffer();
    const audio=await ctx.decodeAudioData(buf);
    const samples=audio.getChannelData(0);

    let start=0, end=samples.length-1;
    while(Math.abs(samples[start])<th && start<end) start++;
    while(Math.abs(samples[end])<th && end>start) end--;

    const cut=samples.slice(start,end);
    const newBuf=ctx.createBuffer(1, cut.length, audio.sampleRate);
    newBuf.copyToChannel(cut,0);

    return audioBufferToWav(newBuf);
}

function audioBufferToWav(buffer){
    const length = buffer.length*2 + 44;
    const ab = new ArrayBuffer(length);
    const vw = new DataView(ab);

    writeWavHeader(vw, buffer.sampleRate, buffer.length);

    let off = 44;
    const smp = buffer.getChannelData(0);
    for(let i=0;i<smp.length;i++,off+=2){
        const s = Math.max(-1, Math.min(1, smp[i]));
        vw.setInt16(off, s<0 ? s*0x8000 : s*0x7FFF, true);
    }
    return new Blob([ab],{type:"audio/wav"});
}

function writeWavHeader(view, rate, len){
    function w(o,s){ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); }
    w(0,"RIFF");
    view.setUint32(4, 36 + len*2, true);
    w(8,"WAVEfmt ");
    view.setUint32(16,16,true);
    view.setUint16(20,1,true);
    view.setUint16(22,1,true);
    view.setUint32(24,rate,true);
    view.setUint32(28,rate*2,true);
    view.setUint16(32,2,true);
    view.setUint16(34,16,true);
    w(36,"data");
    view.setUint32(40,len*2,true);
}

/* ======================= –ó–ê–ì–†–£–ó–ö–ê MP3 –≤ GITHUB ======================= */
function saveToken(){ localStorage.setItem("gh_token", gh_token.value.trim()); }

async function uploadLastMP3(){
    if(!lastMP3Blob) return alert("–ù–µ—Ç MP3. –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—à–∏—Ç–µ –∑–≤—É–∫!");

    const token = localStorage.getItem("gh_token");
    if(!token) return alert("–í–≤–µ–¥–∏—Ç–µ GitHub Token");

    const repo = "ganizhevamirkhan/ingush-language";
    const file = normalizeAudioName(rec_word.value)+".mp3";

    const buf = await lastMP3Blob.arrayBuffer();
    const b64 = btoa([...new Uint8Array(buf)].map(b=>String.fromCharCode(b)).join(""));

    await fetch(`https://api.github.com/repos/${repo}/contents/audio/${file}`,{
        method:"PUT",
        headers:{ "Authorization":"token "+token },
        body: JSON.stringify({
            message:"–î–æ–±–∞–≤–ª–µ–Ω MP3: "+file,
            content:b64
        })
    });

    alert("‚úî –§–∞–π–ª –∑–∞–≥—Ä—É–∂—ë–Ω –≤ GitHub!");
}
</script>

</body>
</html>
