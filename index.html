<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</title>

<style>
body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0;
    background: var(--bg);
    color: var(--fg);
}
:root {
    --bg: #ffffff;
    --fg: #000000;
    --card: #f4f4f4;
}
.dark {
    --bg: #1c1c1c;
    --fg: #f0f0f0;
    --card: #333;
}

.container {
    max-width: 900px;
    margin: auto;
    padding: 20px;
}

input, textarea {
    width: 100%;
    padding: 12px;
    font-size: 16px;
    margin-top: 5px;
}

button {
    padding: 10px 15px;
    margin: 5px;
    font-size: 15px;
    cursor: pointer;
}

.item {
    background: var(--card);
    padding: 15px;
    margin-top: 10px;
    border-radius: 8px;
}

.highlight {
    background: yellow;
    font-weight: bold;
}

#suggestions { background: var(--card); border-radius: 6px; }
.sug-item { padding: 6px; cursor: pointer; }
.sug-item:hover { background: #ddd; }

.edit-block { margin-top: 20px; padding: 15px; background: var(--card); border-radius: 8px; }

.tts-btn { cursor: pointer; margin-left: 8px; }
</style>
</head>

<body class="light">

<div class="container">

<h1>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</h1>

<!-- AUTH BLOCK -->
<div>
    <button onclick="login()">–í–æ–π—Ç–∏</button>
    <button onclick="logout()">–í—ã–π—Ç–∏</button>
    <span id="authStatus"></span>
</div>

<div class="switches">
    <button onclick="setMode('auto')">–ê–≤—Ç–æ</button>
    <button onclick="setMode('ru2ing')">Ru ‚Üí Ing</button>
    <button onclick="setMode('ing2ru')">Ing ‚Üí Ru</button>
    <button onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>
</div>

<input id="query" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ..." oninput="autocomplete()">
<div id="suggestions"></div>

<button onclick="search()">–ü–æ–∏—Å–∫</button>

<div id="result"></div>

<!-- EDITOR BLOCK -->
<div class="edit-block" id="editor" style="display:none;">
    <h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏</h3>

    <label>–†—É—Å—Å–∫–æ–µ —Å–ª–æ–≤–æ:</label>
    <input id="edit_russian">

    <label>–ò–Ω–≥—É—à—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):</label>
    <input id="edit_ingush">

    <label>–ß–∞—Å—Ç—å —Ä–µ—á–∏:</label>
    <input id="edit_pos">

    <label>–¢–æ–ª–∫–æ–≤–∞–Ω–∏–µ:</label>
    <textarea id="edit_definition"></textarea>

    <button onclick="saveEdit()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    <button onclick="closeEditor()">–ó–∞–∫—Ä—ã—Ç—å</button>

    <hr>
    <button onclick="downloadUpdated()">‚¨á –°–∫–∞—á–∞—Ç—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</button>
</div>

</div>

<script>
/* ----------------------------- AUTH ----------------------------- */

const PASSWORD = "ingush-secret"; // ‚Üê –ú–ï–ù–Ø–ô –°–Æ–î–ê –ü–ê–†–û–õ–¨

function updateStatus() {
    document.getElementById("authStatus").innerText =
        localStorage.getItem("authorized") ? "‚úî –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" : "‚úñ –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω";
}

function login() {
    const pass = prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞:");
    if (pass === PASSWORD) {
        localStorage.setItem("authorized", "true");
        alert("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!");
    } else {
        alert("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.");
    }
    updateStatus();
}

function logout() {
    localStorage.removeItem("authorized");
    updateStatus();
}

updateStatus();

/* ----------------------------- THEME ----------------------------- */

function toggleTheme() {
    document.body.classList.toggle("dark");
}

/* ----------------------------- SEARCH ----------------------------- */

let MODE = "auto";
let DICT = {};
let currentEditKey = null;

async function loadDict() {
    const resp = await fetch("merged_dictionary_rebuilt.json");
    DICT = await resp.json();

    // load local edits
    const edits = localStorage.getItem("dict_edits");
    if (edits) {
        const parsed = JSON.parse(edits);
        for (let k in parsed) DICT[k] = parsed[k];
    }
}

loadDict();

function setMode(m) { MODE = m; }

function highlight(text, query) {
    const i = text.toLowerCase().indexOf(query.toLowerCase());
    if (i < 0) return text;
    return (
        text.substring(0, i) +
        "<span class='highlight'>" +
        text.substring(i, i + query.length) +
        "</span>" +
        text.substring(i + query.length)
    );
}

/* --------------------- AUTOCOMPLETE --------------------- */

function autocomplete() {
    const q = query.value.trim();
    if (!q) { suggestions.innerHTML = ""; return; }

    const out = Object.keys(DICT)
        .filter(k => k.startsWith(q))
        .slice(0, 10);

    suggestions.innerHTML = out
        .map(k => `<div class="sug-item" onclick="useSuggestion('${k}')">${highlight(k, q)}</div>`)
        .join("");
}

function useSuggestion(word) {
    query.value = word;
    suggestions.innerHTML = "";
    search();
}

/* ----------------------------- MAIN SEARCH ----------------------------- */

function search() {
    const q = query.value.trim();
    if (!q) return;

    let results = [];

    if (MODE === "ru2ing") {
        results = Object.keys(DICT).filter(k => k.startsWith(q));
    } else if (MODE === "ing2ru") {
        results = Object.keys(DICT).filter(k =>
            DICT[k].ingush.some(i => i.startsWith(q))
        );
    } else {
        results = Object.keys(DICT).filter(k =>
            k.startsWith(q) || DICT[k].ingush.some(i => i.startsWith(q))
        );
    }

    renderResults(results, q);
}

function renderResults(words, q) {
    result.innerHTML = words.map(k => {
        const e = DICT[k];
        return `
        <div class="item">
            <b>${highlight(k, q)}</b>
            <span class="tts-btn" onclick="speakRu('${k}')">üó£</span>
            <br>
            ${e.ingush.join(", ")}
            <span class="tts-btn" onclick="playProtected('${e.ingush[0]}')">üéß</span>
            <br>
            <small>${e.definition || "‚Äî –Ω–µ—Ç —Ç–æ–ª–∫–æ–≤–∞–Ω–∏—è ‚Äî"}</small>
            <br><br>
            ${ localStorage.getItem("authorized") ? 
                `<button onclick="openEditor('${k}')">‚úè –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>` : 
                "" }
        </div>`;
    }).join("");
}

/* ----------------------------- TTS ----------------------------- */

function speakRu(text) {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "ru-RU";
    speechSynthesis.speak(u);
}

function playIng(word) {
    const a = new Audio(`audio/${word}.mp3`);
    a.play();
}

function playProtected(word) {
    if (!localStorage.getItem("authorized")) {
        alert("–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
        return;
    }
    playIng(word);
}

/* ----------------------------- EDITOR ----------------------------- */

function openEditor(key) {
    if (!localStorage.getItem("authorized")) {
        alert("–ù—É–∂–µ–Ω –≤—Ö–æ–¥!");
        return;
    }

    currentEditKey = key;
    const e = DICT[key];

    editor.style.display = "block";

    edit_russian.value = key;
    edit_ingush.value = e.ingush.join(", ");
    edit_pos.value = e.pos || "";
    edit_definition.value = e.definition || "";
}

function closeEditor() {
    editor.style.display = "none";
}

function saveEdit() {
    if (!currentEditKey) return;

    const newKey = edit_russian.value.trim();
    const newIng = edit_ingush.value.split(",").map(x => x.trim()).filter(Boolean);

    DICT[newKey] = {
        russian: newKey,
        ingush: newIng,
        pos: edit_pos.value.trim() || null,
        definition: edit_definition.value.trim() || null,
        source: "edited",
        raw: null
    };

    // save edits locally
    localStorage.setItem("dict_edits", JSON.stringify(DICT));

    alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!");
}

/* ------------------ DOWNLOAD UPDATED DICTIONARY ------------------ */

function downloadUpdated() {
    const blob = new Blob([JSON.stringify(DICT, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "merged_dictionary_UPDATED.json";
    a.click();
}
</script>

</body>
</html>
