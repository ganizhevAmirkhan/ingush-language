<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</title>

<style>
body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 20px;
    background: var(--bg);
    color: var(--fg);
}
:root {
    --bg: #ffffff;
    --fg: #000000;
    --card: #f4f4f4;
}
.dark {
    --bg: #1c1c1c;
    --fg: #f0f0f0;
    --card: #333;
}
.container { max-width: 900px; margin: auto; }

input, textarea {
    width: 100%;
    padding: 12px;
    font-size: 16px;
}
button {
    padding: 10px 15px;
    margin: 5px;
    font-size: 15px;
    cursor: pointer;
}
.item {
    background: var(--card);
    padding: 15px;
    margin-top: 10px;
    border-radius: 8px;
}
.highlight { background: yellow; font-weight: bold; }
#suggestions { background: var(--card); border-radius: 6px; }
.sug-item { padding: 6px; cursor: pointer; }
.sug-item:hover { background: #ddd; }
.edit-block { margin-top: 20px; padding: 15px; background: var(--card); border-radius: 8px; }
.tts-btn { cursor: pointer; margin-left: 8px; font-size: 20px; }
</style>
</head>

<body>
<div class="container">

<h1>–ò–Ω–≥—É—à—Å–∫–æ‚Äì–†—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å</h1>

<button onclick="login()">–í–æ–π—Ç–∏</button>
<button onclick="logout()">–í—ã–π—Ç–∏</button>
<span id="authStatus"></span>

<div>
    <button onclick="setMode('auto')">–ê–≤—Ç–æ</button>
    <button onclick="setMode('ru2ing')">Ru ‚Üí Ing</button>
    <button onclick="setMode('ing2ru')">Ing ‚Üí Ru</button>
    <button onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>
    <button onclick="openAudioAdmin()">üéß –ê—É–¥–∏–æ</button>
</div>

<input id="query" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ..." oninput="autocomplete()">
<div id="suggestions"></div>
<button onclick="search()">–ü–æ–∏—Å–∫</button>

<div id="result"></div>

<!-- EDITOR PANEL -->
<div class="edit-block" id="editor" style="display:none;">
    <h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏</h3>

    <label>–†—É—Å—Å–∫–æ–µ —Å–ª–æ–≤–æ:</label>
    <input id="edit_russian">

    <label>–ò–Ω–≥—É—à—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã:</label>
    <input id="edit_ingush">

    <label>–ß–∞—Å—Ç—å —Ä–µ—á–∏:</label>
    <input id="edit_pos">

    <label>–¢–æ–ª–∫–æ–≤–∞–Ω–∏–µ:</label>
    <textarea id="edit_definition"></textarea>

    <button onclick="saveEdit()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    <button onclick="closeEditor()">–ó–∞–∫—Ä—ã—Ç—å</button>

    <hr>
    <button onclick="downloadUpdated()">‚¨á –°–∫–∞—á–∞—Ç—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</button>
</div>

<!-- AUDIO ADMIN PANEL -->
<div class="edit-block" id="audioAdmin" style="display:none;">
    <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞–º–∏</h3>

    <label>–ò–Ω–≥—É—à—Å–∫–æ–µ —Å–ª–æ–≤–æ:</label>
    <input id="audio_word">

    <label>MP3-—Ñ–∞–π–ª:</label>
    <input type="file" id="audio_file" accept="audio/mp3">

    <button onclick="uploadAudio()">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–º—è —Ñ–∞–π–ª–∞</button>
    <p id="audio_status"></p>

    <hr>
    <button onclick="listMissingAudio()">–ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–æ–≤–∞ –±–µ–∑ –∞—É–¥–∏–æ</button>
    <div id="missing_audio_list"></div>
</div>

</div>

<script>
/* ---------------- AUTH ---------------- */

const PASSWORD = "ingush-secret";

function updateStatus() {
    authStatus.innerText =
        localStorage.getItem("authorized") ? "‚úî –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" : "‚úñ –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω";
}
function login() {
    const pass = prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:");
    if (pass === PASSWORD) localStorage.setItem("authorized", "true");
    else alert("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å");
    updateStatus();
}
function logout() {
    localStorage.removeItem("authorized");
    updateStatus();
}
updateStatus();

/* ---------------- THEME ---------------- */

function toggleTheme() { document.body.classList.toggle("dark"); }

/* ---------------- DICTIONARY ---------------- */

let MODE = "auto";
let DICT = {};
let currentEditKey = null;

async function loadDict() {
    const resp = await fetch("merged_dictionary_rebuilt.json");
    DICT = await resp.json();

    const edits = localStorage.getItem("dict_edits");
    if (edits) Object.assign(DICT, JSON.parse(edits));
}
loadDict();

function setMode(m) { MODE = m; }

/* ---------------- AUTOCOMPLETE ---------------- */

function autocomplete() {
    const q = query.value.trim();
    if (!q) return suggestions.innerHTML = "";

    const matches = Object.keys(DICT)
        .filter(k => k.toLowerCase().startsWith(q.toLowerCase()))
        .slice(0, 10);

    suggestions.innerHTML = matches
        .map(k => `<div class="sug-item" onclick="useSuggestion('${k}')">${k}</div>`)
        .join("");
}
function useSuggestion(w) { query.value = w; suggestions.innerHTML=""; search(); }

/* ---------------- SEARCH ---------------- */

function search() {
    const q = query.value.trim();
    if (!q) return;

    const results = Object.keys(DICT).filter(k => {
        if (MODE === "ru2ing") return k.startsWith(q);
        if (MODE === "ing2ru") return DICT[k].ingush.some(i => i.startsWith(q));
        return k.startsWith(q) || DICT[k].ingush.some(i => i.startsWith(q));
    });

    renderResults(results, q);
}

function renderResults(keys, q) {
    result.innerHTML = keys.map(k => {
        const e = DICT[k];
        return `
        <div class="item">
            <b>${k}</b>
            <span class="tts-btn" onclick="speakRu('${k}')">üó£</span><br>
            ${e.ingush.join(", ")}
            <span class="tts-btn" onclick="playProtected('${e.ingush[0]}')">üéß</span>
            <br>
            <small>${e.definition || "‚Äî –Ω–µ—Ç —Ç–æ–ª–∫–æ–≤–∞–Ω–∏—è ‚Äî"}</small><br><br>
            ${localStorage.getItem("authorized") ?
                `<button onclick="openEditor('${k}')">‚úè –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>` : ""}
        </div>`;
    }).join("");
}

/* ---------------- TTS ---------------- */

function speakRu(text) {
    const ut = new SpeechSynthesisUtterance(text);
    ut.lang = "ru-RU";
    speechSynthesis.speak(ut);
}

/* ---------------- AUDIO NORMALIZATION (LATIN STYLE) ---------------- */

function latinize(str) {
    const map = {
        "–∞":"a","–±":"b","–≤":"v","–≥":"g","–¥":"d","–µ":"e","—ë":"yo","–∂":"zh","–∑":"z",
        "–∏":"i","–π":"y","–∫":"k","–ª":"l","–º":"m","–Ω":"n","–æ":"o","–ø":"p","—Ä":"r",
        "—Å":"s","—Ç":"t","—É":"u","—Ñ":"f","—Ö":"kh","—Ü":"ts","—á":"ch","—à":"sh","—â":"shh",
        "—ä":"", "—ã":"y","—å":"", "—ç":"e","—é":"yu","—è":"ya",
        "”Ä":"i","”è":"i","‚Äô":""
    };
    return str.toLowerCase().split("").map(c => map[c] || c).join("");
}

function normalizeAudioName(word) {
    const lat = latinize(word);
    return lat.replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}

function playIng(word) {
    const file = normalizeAudioName(word);
    const audio = new Audio(`audio/${file}.mp3`);

    audio.play().catch(() => {
        // FALLBACK GOOGLE TTS
        const url = "https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q="
            + encodeURIComponent(word)
            + "&tl=ru"; 
        new Audio(url).play();
    });
}

function playProtected(word) {
    if (!localStorage.getItem("authorized")) {
        alert("–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
        return;
    }
    playIng(word);
}

/* ---------------- EDITOR ---------------- */

function openEditor(key) {
    if (!localStorage.getItem("authorized")) return alert("–ù—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!");
    currentEditKey = key;

    const e = DICT[key];
    edit_russian.value = key;
    edit_ingush.value = e.ingush.join(", ");
    edit_pos.value = e.pos || "";
    edit_definition.value = e.definition || "";

    editor.style.display = "block";
}
function closeEditor() { editor.style.display = "none"; }

function saveEdit() {
    const rus = edit_russian.value.trim();
    const ing = edit_ingush.value.split(",").map(s => s.trim()).filter(Boolean);

    DICT[rus] = {
        russian: rus,
        ingush: ing,
        pos: edit_pos.value.trim(),
        definition: edit_definition.value.trim(),
        source: "edited"
    };

    localStorage.setItem("dict_edits", JSON.stringify(DICT));
    alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!");
}

/* ---------------- DOWNLOAD ---------------- */

function downloadUpdated() {
    const blob = new Blob([JSON.stringify(DICT, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "dictionary_updated.json";
    a.click();
}

/* ---------------- AUDIO ADMIN ---------------- */

function openAudioAdmin() {
    if (!localStorage.getItem("authorized")) return alert("–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!");
    audioAdmin.style.display = "block";
}

function uploadAudio() {
    const word = audio_word.value.trim();
    if (!word) return audio_status.innerText = "–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ!";

    const file = normalizeAudioName(word);

    audio_status.innerHTML =
        `–ò–º—è —Ñ–∞–π–ª–∞: <b>${file}.mp3</b><br>
         –ó–∞–≥—Ä—É–∑–∏—Ç–µ mp3 –≤—Ä—É—á–Ω—É—é –≤ GitHub ‚Üí audio/${file}.mp3`;
}

function listMissingAudio() {
    const seen = new Set();
    let html = "<h4>–°–ª–æ–≤–∞ –¥–ª—è –æ–∑–≤—É—á–∫–∏:</h4><ul>";

    for (const k in DICT) {
        DICT[k].ingush.forEach(i => {
            const f = normalizeAudioName(i);
            if (!seen.has(f)) {
                seen.add(f);
                html += `<li>${i} ‚Üí <code>${f}.mp3</code></li>`;
            }
        });
    }

    html += "</ul>";
    missing_audio_list.innerHTML = html;
}
</script>

</body>
</html>
